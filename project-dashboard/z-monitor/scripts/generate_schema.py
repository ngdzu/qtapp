#!/usr/bin/env python3
"""
Database Schema Code Generator

Generates C++ header files and SQL DDL from YAML schema definition.

Usage:
    python3 scripts/generate_schema.py
    
Input:
    schema/database.yaml
    
Output:
    src/infrastructure/persistence/generated/SchemaInfo.h
    schema/generated/ddl/create_tables.sql
    schema/generated/ddl/create_indices.sql
"""

import yaml
import os
import sys
from datetime import datetime, timezone
from typing import Dict, List, Any
from pathlib import Path

def to_cpp_constant(name: str) -> str:
    """Convert database column/table name to C++ constant name."""
    # Convert to UPPER_SNAKE_CASE
    return name.upper().replace('.', '_')

def to_cpp_namespace(name: str) -> str:
    """Convert table name to C++ namespace name (PascalCase)."""
    # Convert snake_case to PascalCase
    parts = name.split('_')
    return ''.join(word.capitalize() for word in parts)

def load_schema(schema_file: str) -> Dict[str, Any]:
    """Load YAML schema file."""
    try:
        with open(schema_file, 'r') as f:
            return yaml.safe_load(f)
    except FileNotFoundError:
        print(f"‚ùå Error: Schema file not found: {schema_file}")
        sys.exit(1)
    except yaml.YAMLError as e:
        print(f"‚ùå Error: Invalid YAML in {schema_file}: {e}")
        sys.exit(1)

def generate_schema_header(schema: Dict[str, Any], output_file: str):
    """Generate SchemaInfo.h C++ header file."""
    
    timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
    version = schema.get('version', '1.0.0')
    
    header = f"""/**
 * @file SchemaInfo.h
 * @brief Auto-generated database schema constants.
 * 
 * ‚ö†Ô∏è DO NOT EDIT THIS FILE MANUALLY ‚ö†Ô∏è
 * 
 * This file is auto-generated from schema/database.yaml
 * To make changes:
 *   1. Edit schema/database.yaml
 *   2. Run: python3 scripts/generate_schema.py
 *   3. Commit both files together
 * 
 * Generated: {timestamp}
 * Schema Version: {version}
 */

#ifndef SCHEMAINFO_H
#define SCHEMAINFO_H

#include <string>

/**
 * @namespace Schema
 * @brief Database schema constants (table names, column names, constraints).
 * 
 * Use these constants instead of hardcoded strings to ensure type safety
 * and enable refactoring.
 */
namespace Schema {{

/**
 * @namespace Tables
 * @brief Table name constants.
 */
namespace Tables {{
"""
    
    # Generate table name constants
    for table_name in sorted(schema['tables'].keys()):
        const_name = to_cpp_constant(table_name)
        table_def = schema['tables'][table_name]
        description = table_def.get('description', table_name)
        header += f'    ///< {description}\n'
        header += f'    constexpr const char* {const_name} = "{table_name}";\n'
    
    header += "}\n\n"
    header += "/**\n * @namespace Columns\n * @brief Column name constants organized by table.\n */\n"
    header += "namespace Columns {\n"
    
    # Generate column name constants for each table
    for table_name in sorted(schema['tables'].keys()):
        table_def = schema['tables'][table_name]
        namespace_name = to_cpp_namespace(table_name)
        description = table_def.get('description', table_name)
        
        header += f"\n    /**\n     * @namespace {namespace_name}\n     * @brief Column names for {table_name} table.\n     *\n     * {description}\n     */\n"
        header += f"    namespace {namespace_name} {{\n"
        
        for col_name, col_def in sorted(table_def['columns'].items()):
            const_name = to_cpp_constant(col_name)
            col_description = col_def.get('description', col_name)
            
            # Check if deprecated
            if col_def.get('deprecated'):
                deprecation_note = col_def.get('replacement', '')
                header += f'        ///< DEPRECATED: {col_description}'
                if deprecation_note:
                    header += f' (Use {deprecation_note} instead)'
                header += '\n'
            else:
                header += f'        ///< {col_description}\n'
            
            header += f'        constexpr const char* {const_name} = "{col_name}";\n'
        
        header += "    }\n"
    
    header += "}\n\n"
    
    # Generate constraint constants (if any)
    header += "/**\n * @namespace Constraints\n * @brief Constraint definitions for validation.\n */\n"
    header += "namespace Constraints {\n"
    
    for table_name in sorted(schema['tables'].keys()):
        table_def = schema['tables'][table_name]
        namespace_name = to_cpp_namespace(table_name)
        
        # Extract check constraints from columns
        has_constraints = False
        constraint_lines = []
        
        for col_name, col_def in table_def['columns'].items():
            if 'check' in col_def:
                has_constraints = True
                check_expr = col_def['check']
                # Extract valid values if it's an IN clause
                if 'IN (' in check_expr:
                    values = check_expr.split('IN (')[1].split(')')[0].strip()
                    values = [v.strip().strip("'\"") for v in values.split(',')]
                    const_name = to_cpp_constant(col_name)
                    constraint_lines.append(f"        // Valid values for {col_name}: {', '.join(values)}")
        
        if has_constraints:
            header += f"\n    namespace {namespace_name} {{\n"
            for line in constraint_lines:
                header += f"{line}\n"
            header += "    }\n"
    
    header += "}\n\n"
    header += "} // namespace Schema\n\n"
    header += "#endif // SCHEMAINFO_H\n"
    
    # Write to file
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    with open(output_file, 'w') as f:
        f.write(header)
    
    print(f"‚úÖ Generated: {output_file}")

def generate_ddl(schema: Dict[str, Any], output_dir: str):
    """Generate SQL DDL files."""
    
    timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
    version = schema.get('version', '1.0.0')
    
    create_tables_sql = f"""-- Auto-generated DDL for table creation
-- Generated: {timestamp}
-- Schema Version: {version}
-- ‚ö†Ô∏è DO NOT EDIT MANUALLY - Edit schema/database.yaml and regenerate

"""
    
    for table_name in sorted(schema['tables'].keys()):
        table_def = schema['tables'][table_name]
        description = table_def.get('description', table_name)
        
        create_tables_sql += f"\n-- {description}\n"
        create_tables_sql += f"CREATE TABLE IF NOT EXISTS {table_name} (\n"
        
        columns = []
        for col_name, col_def in table_def['columns'].items():
            col_sql = f"    {col_name} {col_def['type']}"
            
            if col_def.get('primary_key'):
                col_sql += " PRIMARY KEY"
            if col_def.get('autoincrement'):
                col_sql += " AUTOINCREMENT"
            if col_def.get('not_null'):
                col_sql += " NOT NULL"
            if col_def.get('unique'):
                col_sql += " UNIQUE"
            if 'default' in col_def:
                col_sql += f" DEFAULT {col_def['default']}"
            if 'check' in col_def:
                col_sql += f" CHECK ({col_def['check']})"
            
            # Add comment
            if 'description' in col_def:
                col_sql += f"  -- {col_def['description']}"
            
            columns.append(col_sql)
        
        # Add foreign keys
        for col_name, col_def in table_def['columns'].items():
            if 'foreign_key' in col_def:
                fk = col_def['foreign_key']
                fk_sql = f"    FOREIGN KEY ({col_name}) REFERENCES {fk['table']}({fk['column']})"
                if 'on_delete' in fk:
                    fk_sql += f" ON DELETE {fk['on_delete']}"
                if 'on_update' in fk:
                    fk_sql += f" ON UPDATE {fk['on_update']}"
                columns.append(fk_sql)
        
        # Add table constraints
        if 'constraints' in table_def:
            for constraint in table_def['constraints']:
                columns.append(f"    CONSTRAINT {constraint['name']} CHECK ({constraint['check']})")
        
        create_tables_sql += ",\n".join(columns)
        create_tables_sql += "\n);\n"
    
    # Write CREATE TABLES
    os.makedirs(output_dir, exist_ok=True)
    create_tables_file = os.path.join(output_dir, "create_tables.sql")
    with open(create_tables_file, 'w') as f:
        f.write(create_tables_sql)
    print(f"‚úÖ Generated: {create_tables_file}")
    
    # Generate CREATE INDICES
    create_indices_sql = f"""-- Auto-generated DDL for index creation
-- Generated: {timestamp}
-- ‚ö†Ô∏è DO NOT EDIT MANUALLY - Edit schema/database.yaml and regenerate

"""
    
    for table_name in sorted(schema['tables'].keys()):
        table_def = schema['tables'][table_name]
        if 'indices' in table_def:
            for index in table_def['indices']:
                unique = "UNIQUE " if index.get('unique') else ""
                columns_str = ", ".join(index['columns'])
                create_indices_sql += f"CREATE {unique}INDEX IF NOT EXISTS {index['name']} "
                create_indices_sql += f"ON {table_name} ({columns_str})"
                if 'where' in index:
                    create_indices_sql += f" WHERE {index['where']}"
                create_indices_sql += ";\n"
            create_indices_sql += "\n"
    
    create_indices_file = os.path.join(output_dir, "create_indices.sql")
    with open(create_indices_file, 'w') as f:
        f.write(create_indices_sql)
    print(f"‚úÖ Generated: {create_indices_file}")

def main():
    """Main entry point."""
    # Get script directory (assumes script is in z-monitor/scripts/)
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    
    schema_file = project_root / "schema" / "database.yaml"
    header_output = project_root / "src" / "infrastructure" / "persistence" / "generated" / "SchemaInfo.h"
    ddl_output_dir = project_root / "schema" / "generated" / "ddl"
    
    print("üìä Z Monitor Schema Code Generator")
    print(f"üìÇ Loading schema: {schema_file}")
    
    if not schema_file.exists():
        print(f"‚ùå Error: Schema file not found: {schema_file}")
        sys.exit(1)
    
    schema = load_schema(str(schema_file))
    
    print(f"üî® Generating C++ header...")
    generate_schema_header(schema, str(header_output))
    
    print(f"üî® Generating SQL DDL...")
    generate_ddl(schema, str(ddl_output_dir))
    
    print("‚úÖ Schema generation complete!")
    print("\nüìù Next steps:")
    print("  1. Review generated files")
    print("  2. Commit schema/database.yaml + generated files together")
    print("  3. Run: cmake --build build")

if __name__ == "__main__":
    main()

