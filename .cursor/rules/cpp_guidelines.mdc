---
appliesTo:
  - "**/*.cpp"
  - "**/*.cxx"
  - "**/*.cc"
  - "**/*.h"
  - "**/*.hpp"
  - "src/**/*.cpp"
  - "src/**/*.h"
---
# C++ Implementation Guidelines

- Target C++17 throughout the project and enable warnings-as-errors when possible.
- Favor RAII: wrap ownership in smart pointers (`std::unique_ptr`, `std::shared_ptr`) or rely on Qt’s parent/child relationships.
- Prefer `const` correctness and `[[nodiscard]]` for functions returning values that must be handled.
- Avoid raw `new`/`delete`; if dynamic allocation is required, encapsulate it in helpers or use stack-based objects.
- Keep translation units focused; each `.cpp` should correspond to a single class or cohesive feature.
- Use `#pragma once` in headers and keep include order: own header, project headers, Qt headers, then STL/system.
- For Qt signal-slot connections, prefer function/lambda overloads with context objects to prevent leaks.
- Document tricky logic with concise comments explaining the “why,” not the “what.”
- **Avoid relative include paths** - Do not use relative include paths such as `#include "../path/to/header.h"` or `#include "../../other/Thing.h"`. Instead, add the path to the include search path via CMake (using `target_include_directories` in `CMakeLists.txt`). Then include headers using their project-relative path (for example, `#include "domain/monitoring/PatientAggregate.h"`). This ensures that if files are moved, the include statements won't break, and centralizes path management in the build system.
- **Use short, lowercase namespace names** - Namespace names should be short and in lowercase. For example, use `zmon` instead of `ZMonitor`, `infra` instead of `Infrastructure`, `app` instead of `Application`, `domain` instead of `Domain`. This keeps namespace declarations concise and reduces typing overhead. Example: `namespace zmon { namespace infra { namespace sensors { ... } } }` instead of `namespace ZMonitor { namespace Infrastructure { namespace Sensors { ... } } }`.
